<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 并发编程笔记（三）</title>
    <link href="/2022/07/31/java-concurrent-3/"/>
    <url>/2022/07/31/java-concurrent-3/</url>
    
    <content type="html"><![CDATA[<h2 id="Concurrent-集合"><a href="#Concurrent-集合" class="headerlink" title="Concurrent 集合"></a>Concurrent 集合</h2><ul><li><code>BlockingQueue</code> FIFO 数据结构，在调用<code>add()</code>和<code>remove()</code>方法的时候会进行阻塞，同时还提供了<code>offer(e, time, unit)</code>和<code>poll(time, unit)</code>这种在超时前尝试操作的方法。</li><li><code>ConcurrentHashMap</code> 提供了具备原子性的方法，而不是使用 synchronized 关键字，性能更好。</li><li><code>CopyOnWriteArrayList</code> 是多线程下<code>ArrayList</code>的替代品。</li></ul><h3 id="Copy-On-Write-写时复制"><a href="#Copy-On-Write-写时复制" class="headerlink" title="Copy On Write 写时复制"></a>Copy On Write 写时复制</h3><p>这是一种读写分离的并发策略。适合读多写少的场景。</p><ul><li>对于读。不需要任何保护，直接读即可。</li><li>对于写。会直接复制整个集合，对复制后的集合进行写入，然后将原本的引用指向新的集合地址。写的过程会加锁，不允许多线程同时写，否则会出现线程干扰。由于写操作的最后一步将引用指向新的拷贝的过程时原子性的，并且使用了 volatile 关键字，会马上刷新到主存种，因此写线程并不会影响到读线程。</li></ul><p>此外，在遍历这种容器的时候，是不会抛出<code>UnsupportedOperationException</code>的，因为它的迭代器会指向当时的数组，而写操作并不会改变改数组，而是改变其拷贝。</p><p>但是这个并发策略有以下缺点：</p><ol><li>每次写入都要复制原本的数组，会占用很多内存，同时也会需要频繁的垃圾回收。</li><li>读线程无法马上得到实时的数据，只有在写线程将数组的引用转向新地址后，读线程才能同步数据。</li></ol><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。在大型的应用中，可以将线程的创建和管理与应用的其他部分分开。在 Java 中，封装了这些功能的对象就是执行器（Executor）。</p><h3 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h3><p>在<code>java.util.concurrent</code>包中有三个 executor 接口：</p><ul><li><code>Executor</code>。</li><li><code>ExecutorService</code>。增加了管理线程和执行器本身的生命周期管理功能</li><li><code>ScheduledExecutorService</code>。增加了未来（Future）和周期性（Periodic）执行的功能。</li></ul><p>Executor 使用 execute() 方法来注册启动一个任务（必须是 Runable），而 ExecutorService 可以使用更高级的 submit() 方法注册一个任务（可以时 Runable 或者 Callable），它返回一个 Future 对象，用于接受 Callable 任务的返回值。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>上述的各种执行器接口的实现大多数使用线程池。线程池由许多工人线程组成（Worker Threads）。这些工人线程由线程池来维护，可以避免过多的创建新的线程，因为每一个线程都有一定的内存开销，而且在大型应用中，新建和取消一个线程的开销很大。</p><p>Java 提供了许多不同的线程池类型，以下是线程池的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Fixed size thread pool</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// Expandable size thread pool</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// customize thread pool</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(...);<br></code></pre></td></tr></table></figure><p>线程池的优点：</p><ol><li>复用线程，降低资源消耗</li><li>提高响应速度</li><li>提高线程可管理性</li></ol><h3 id="Fork-x2F-Join-线程池"><a href="#Fork-x2F-Join-线程池" class="headerlink" title="Fork&#x2F;Join 线程池"></a>Fork&#x2F;Join 线程池</h3><p>Fork&#x2F;Join 框架是一个 ExecutorService 的实现，帮助开发者利用多线程的优势。它被用于能够被递归式地拆分成更小的任务的任务。它的核心是<code>ForkJoinPool</code>类。</p><p>要使用这个类，首先要实现<code>RecursiveTask</code>（有返回值）或者<code>RecursiveAction</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputeSomething</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveAction</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isReachingRecursiveBase)<br>        &#123;<br>            <span class="hljs-comment">// do something</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        invokeAll(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComputeSomething</span>(halfOfTheCalculation),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComputeSomething</span>(anotherHalfOfTheCalculation));<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来使用 ForkJoinPool 来计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ComputeSomething</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComputeSomething</span>(theWholeComputation);<br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>pool.invoke(cs);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 并发编程笔记（二）</title>
    <link href="/2022/07/30/java-concurrent-2/"/>
    <url>/2022/07/30/java-concurrent-2/</url>
    
    <content type="html"><![CDATA[<h2 id="并发的“活力”"><a href="#并发的“活力”" class="headerlink" title="并发的“活力”"></a>并发的“活力”</h2><p>并发的场景下一般有三个“活力”的问题，分别是死锁、活锁和饥饿。</p><p>假如有这个场景：</p><ul><li>线程 P1 占有资源 A，请求资源 B</li><li>线程 P2 占有资源 B，请求资源 A</li></ul><p>这种情况下，如果请求的过程是等待式的，那么两个线程就会都陷入等待中，那就是死锁。两个线程不是等待式，而是发现资源被占有就回滚重新开始，那么两个线程就可能会陷入重复不断的开始-回滚循环中，这就是活锁。</p><p>多线程执行中有线程优先级这个概念，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。</p><h2 id="守护代码块（Guarded-Blocks）与-wait-、notify"><a href="#守护代码块（Guarded-Blocks）与-wait-、notify" class="headerlink" title="守护代码块（Guarded Blocks）与 wait()、notify()"></a>守护代码块（Guarded Blocks）与 wait()、notify()</h2><p>守护代码块一般是循环等待一个条件，直到条件符合再继续运行的一个代码块。<br>反面案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">guardedJoy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Simple loop guard. Wastes</span><br>    <span class="hljs-comment">// processor time. Don&#x27;t do this!</span><br>    <span class="hljs-keyword">while</span>(!joy) &#123;&#125;<br>    System.out.println(<span class="hljs-string">&quot;Joy has been achieved!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个情况会浪费 cpu。另外，可以看到这个方法没有 synchronized 关键字，如果有，它就会锁住这个对象，这样其他对象就无法改变 joy 的值，这个循环就会一直持续下去。</p><p>正面案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">guardedJoy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// This guard only loops once for each special event, which may not</span><br>    <span class="hljs-comment">// be the event we&#x27;re waiting for.</span><br>    <span class="hljs-keyword">while</span>(!joy) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Joy and efficiency have been achieved!&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当代码执行到 wait() 的时候，这个线程会停下来等待其他线程的 notifyAll(), 如果该线程被唤醒，但是 joy 还没被更改，它又会再次等待并让出该类的锁，直到其他线程改变了 joy 的值并唤醒了该线程。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>对于 JVM 来说如果有一个线程没有退出，JVM 进程就不会退出。所以，必须保证所有线程都能及时结束。 有的线程的目的就是不断循环，为其他线程服务，然而，如果这个线程不结束，整个 JVM 进程就无法结束。使用守护线程可以解决这个问题，当所有线程已经结束后，无论有无守护线程，JVM 都会结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure><h2 id="其它锁"><a href="#其它锁" class="headerlink" title="其它锁"></a>其它锁</h2><p>上一篇笔记中讲了 synchronized 其实内部就是用了一个简单的重入锁（Reentrant Lock），在<code>java.util.concurrent.locks</code>包中提供了不同的锁类，包括 ReentrantLock、ReadWriteLock 和 StempedLock 等等。</p><h3 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock 重入锁"></a>ReentrantLock 重入锁</h3><p>这个类和 synchronized 提供的功能类似，但是它提供了 tryLock() 方法。tryLock() 方法可以在限定的时间内尝试获得锁，能获得就返回 true 否则返回 false。使用 ReentrantLock 会比 synchronization 更加安全，因为不会导致死锁。</p><p>要注意的是，自己使用 lock 要先在 try 之前得到锁，然后进入 try{…}, 最后在 finally 中解锁。</p><h4 id="使用-Condition"><a href="#使用-Condition" class="headerlink" title="使用 Condition"></a>使用 Condition</h4><p>在 synchronized 中可以使用 wait()、notifyAll() 等方法实现前文说到 Guarded Blocks，但在 ReentrantLock 中需要使用 Condition 类。</p><p>要使用 Condition，首先要从 lock 中获得它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure><p>Condition 提供了 await()、Signal()、SignalAll() 等方法，原理和 synchronized 的 wait()、notify()、notifyAll() 是一致的。此外，await() 还能够在等待指定事件后自己醒来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (condition.await(<span class="hljs-number">1</span>, TimeUnit.SECOND)) &#123;<br>    <span class="hljs-comment">// get signal from other thread</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// waiting time-out</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><p>假如有一个类提供了读、写两个方法，使用重入锁，会出现下面的情况：</p><ol><li>读、写均上锁：<br>此时只有一个线程能对该类进行操作，无论读写。</li><li>只对写上锁：<br>进行读操作的线程会忽略其他线程正在写入的内容。如果数据不只是一个变量，则读也不是原子操作，这种情况下可能读出错误的结果。</li></ol><p>如果我们需要如下的方案，使用重入锁则无法解决：</p><ul><li>允许多个线程同时读</li><li>当有一个线程在写的时候，其余的线程都要等待</li><li>当有线程在读的时候，写线程也要等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">rlock</span> <span class="hljs-operator">=</span> rwlock.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">wlock</span> <span class="hljs-operator">=</span> rwlock.writeLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        wlock.lock(); <br>        <span class="hljs-keyword">try</span> &#123;<br>            counts[index] += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            wlock.unlock(); <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] get() &#123;<br>        rlock.lock(); <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.copyOf(counts, counts.length);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rlock.unlock(); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StampedLock-邮戳锁"><a href="#StampedLock-邮戳锁" class="headerlink" title="StampedLock 邮戳锁"></a>StampedLock 邮戳锁</h3><p>读写锁悲观地估计在读时会有其他线程想进行写入，因此它在读锁没释放不会释放写锁，所以它是悲观锁。这一过程很可能会拖累程序的并发效率，因此我们需要引入新的读写锁——邮戳锁。</p><p>邮戳锁是乐观锁，它在读操作时乐观地假设没有其他线程进行写操作，于是允许写入的过程。但是这种情况下，一旦有小概率的写入导致最终读取的数据不正确，则需要额外检测和重读。</p><p>具体实现上，写方法的实现和读写锁一样，但是读方法有不同：</p><ol><li>首先获取乐观读锁，读取数据</li><li>读取完后对比乐观锁的邮戳</li><li>如果发现读的过程中有写入，则换成悲观锁再读一次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br><br>    <span class="hljs-comment">// write method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock(); <br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// read method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead();<br>        <span class="hljs-comment">// there is two variables, the action is not atomic.</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentY</span> <span class="hljs-operator">=</span> y;<br><br>        <span class="hljs-comment">// check stamp, if there is any write action after obtain</span><br>        <span class="hljs-comment">// the optimistic read lock.</span><br>        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123;<br>            <span class="hljs-comment">// a pessimistic lock this time.</span><br>            stamp = stampedLock.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在使用邮戳锁时，在频繁的读线程中，写线程总是能够在第一次成功写入，然后被干扰的读线程们就会再使用悲观读锁将内容读出。下一次写线程又能在悲观锁们释放之后继续写入，避免了读线程十分频繁，导致写线程一直等待无法写入的情况。</p><p>生动的说，假如有两个不能同时出水的水龙头分别为读和写，邮戳锁就能够让这两个水龙头交替出水，在读操作的洪流中，间歇性地穿插放出写操作，防止写操作被一直阻塞。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 并发编程笔记（一）</title>
    <link href="/2022/07/29/java-concurrent-1/"/>
    <url>/2022/07/29/java-concurrent-1/</url>
    
    <content type="html"><![CDATA[<p>并发编程可能会出现两种问题，一个是线程干扰（Thread Interference），一个是内存一致性错误（Memory Consistency Error）。</p><h2 id="线程干扰"><a href="#线程干扰" class="headerlink" title="线程干扰"></a>线程干扰</h2><p>线程干扰就是两个线程同时读写一个数据，有的操作会被覆盖。如下，A 的操作会被覆盖：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Text">Thread A: Retrieve c.<br>Thread B: Retrieve c.<br>Thread A: Increment retrieved value; result is 1.<br>Thread B: Decrement retrieved value; result is -1.<br>Thread A: Store result in c; c is now 1.<br>Thread B: Store result in c; c is now -1.<br></code></pre></td></tr></table></figure><p>有一种操作不需要考虑线程干扰问题，那就是<strong>原子性</strong>操作。有以下：</p><ul><li>对引用变量和除了 long 和 double 的原始类型变量的读或者写。</li><li>对所有使用了 volatile 关键字的变量的读或写。</li></ul><p><em>*注意都是读或写，其他操作如<code>i++</code>是非原子性的。</em></p><p>使用原子性的变量会比使用 synchronized 关键字性能更好。<code>java.util.concurrent</code>包提供了多原子性类。</p><h2 id="内存一致性"><a href="#内存一致性" class="headerlink" title="内存一致性"></a>内存一致性</h2><p>主要来源于可见性（Visibility）问题和重排序（Re-ordering）问题。</p><p>可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。(Java 内存模型中，每个线程都有自己的工作内存，这些内存中的值来自一个主内存。多线程时，工作内存被写入，并不一定会马上写入到主内存中，这样其他的线程可能看不到该变动）。</p><p>在 Java 内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。</p><p>volatile 关键字可以解决上述两个内存一致性问题。</p><h2 id="关键字-synchronized-和-volatile"><a href="#关键字-synchronized-和-volatile" class="headerlink" title="关键字 synchronized 和 volatile"></a>关键字 synchronized 和 volatile</h2><p>synchronized 通常称为重量级锁，而 volatile 更轻量级，不会引起线程上下文切换和调度。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 可以同时解决线程干扰和内存一致性的问题，但是有一定的开销。</p><p>同步方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>    count += value;<br>&#125;<br></code></pre></td></tr></table></figure><p>同步块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>    <span class="hljs-comment">// 如果是同步方法，必须显式的提供该锁的类。</span><br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>        count += value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时只能有一个线程执行同步块或同步方法。相当于是其他的线程要阻塞并等待正在调用同步方法的线程结束调用。</p><p>synchronized 是基于每个对象的内在锁实现的。每个线程要访问一个对象的 synchronized 方法的时候，都会先获取它的内在锁，完成后再释放它。其他想要访问这个对象的 synchronized 方法的线程都会阻塞，因为一个锁只能被一个线程拥有。如果一个线程已经拥有某个对象的锁，那它可以多次拥有该锁，同时它也会多次释放该锁。对于 Static 的 synchronized 方法，则会获得该 Class 对象的锁。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="作用：保证内存一致性"><a href="#作用：保证内存一致性" class="headerlink" title="作用：保证内存一致性"></a>作用：保证内存一致性</h5><p>volatile 关键字用于解决并发编程中的内存一致性问题。</p><p>关于可见性。如果变量使用了 volatile 关键字：</p><ul><li>在写入的时候会将变量强制刷新到主内存去。</li><li>在读的时候，会从主内存中读。</li></ul><p>这样别的线程就可以看到该变量的更新，解决了可见性问题。</p><p>关于重排序。volatile 关键字保证了在运行到读写该变量的操作时：</p><ul><li>该操作之前的所有操作均完成。</li><li>该操作之后的操作均未进行。</li></ul><p>这样就保证了程序运行的有序性。</p><h5 id="局限：不能解决线程干扰"><a href="#局限：不能解决线程干扰" class="headerlink" title="局限：不能解决线程干扰"></a>局限：不能解决线程干扰</h5><p>volatile 不能解决线程干扰。如过对 volatile 变量使用了非原子性操作，不能保证不被其他线程干扰。比如，<code>i++</code>。这一操作需要：</p><ol><li>将 i 的值从内存中取回</li><li>计算 i++</li><li>将结果放回内存。</li></ol><p>因为使用了 volatile 关键字，确保了 1 和 3 过程中都从主存中存取。但是，其他的线程在 1、3 过程中也可能进行了存取，这样就导致了有一个线程的结果会被忽略。</p><p>因此，volatile 变量主要用在多线程情况下的原子操作中，可以用作某个状态的标识，在这种情况下性能会比原子类或者 synchronized 关键字有更好的性能。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>synchronized</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS:APP Attacklab 心得</title>
    <link href="/2020/10/05/csapp-attack-lab/"/>
    <url>/2020/10/05/csapp-attack-lab/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上个月全心全意复习雅思，CSAPP 的学习之路也就暂停了一个月。前几天雅思成绩出来了，也没有辜负我的努力，一步到位 7 分，不用再考了。这两天把 csapp 的 <a href="http://csapp.cs.cmu.edu/3e/labs.html">attack lab</a> 做了，还写了个注释，方便做完写博客记录。前面两个 lab 没有记录，以后有空的话也许会补一下吧。</p><h2 id="Attack-Lab"><a href="#Attack-Lab" class="headerlink" title="Attack Lab"></a>Attack Lab</h2><p>顾名思义，这个 lab 就是通过栈溢出来进行攻击，主要有代码注入 (Code Injection) 和 ROP 攻击 (Return-Oriented Programming)。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Text">|------------<br>|<br>| function 1<br>|<br>|------------<br>| addr 1<br>|------------<br>|<br>| function 2<br>|<br>|------------<br>|   ......<br></code></pre></td></tr></table></figure><p>程序运行的时候，栈是分层的，每个函数在调用其他函数时，会将自己的地址入栈，等执行下一个函数的<code>ret</code>指令时，栈顶的内容就是返回位置的地址。如上图，function2 返回前会将 rsp 栈指针寄存器指向<code>addr 1</code>, 也就是函数 1 的位置。而栈溢出就是通过写入过量的内容，导致缓冲区溢出，覆盖掉返回地址，从而可以跳转到攻击者指定的内存地址。</p><h3 id="Code-Injection"><a href="#Code-Injection" class="headerlink" title="Code Injection"></a>Code Injection</h3><p>代码注入就是在缓冲区直接写入需要的代码内容，并在将返回地址修改成写入内容的地址，这样就可以让程序运行攻击者的代码。Attack Lab 的前三题就是使用代码注入攻击。</p><h4 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h4><p>这一题非常简单，要求调用函数<code>touch1</code>即可，只需要将缓冲区溢出，让返回地址指向上述函数即可。</p><p>将 ctarget 用 gdb 打开，可以看到这个程序先是执行 test 函数，然后 test 函数会调用 getbuf 函数，后者就是这个 lab 的关键：getbuf 函数中调用的 GETS 函数会使栈溢出，getbuf 的返回地址可以被覆盖，从而使程序不返回到 test 函数中而是去向攻击者指定的地址。</p><p>答案如下，前 5 行是 40 字节的填充内容，最后一行是 touch1 函数的地址，注意小字节序。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Text">00 00 00 00 00 00 00 00<br>c0 17 40 00 00 00 00 00<br>/*<br>  |     return addr     |<br>  |---------------------|<br>  |                     |<br>  |     40 bytes        |<br>  |  0x28 bytes stack   |<br><br>overwrite the return address and <br>directly return to touch1(). */<br><br></code></pre></td></tr></table></figure><h4 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h4><p>第二题是第一题的延申，这次要调用的是 touch2 函数，传入了一个参数，我们需要注入合适的代码来实现。</p><p>寄存器<code>%rdi</code>的内容就是函数的第一个参数，思路图如下。首先注入 40 字节的 00 填充缓冲区，然后将返回地址覆盖为注入代码的开头，不难，数一下即可。注入代码首先将 cookie 写入%rdi 中，然后将下一个返回地址（touch2 函数的地址）入栈，最后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">/*<br>|.....<br>|-------- -&gt; write first argunement (a)<br>|0x8      -&gt; push ret addr<br>|test1()  -&gt; ret (0x5561dca8) <br>|--------<br>|ret addr -&gt; jump to (a)<br>|--------         <br>|0x28     -&gt; all 00 to make the stack overflow.<br>|getbuff()<br>|--------   -&gt; 0x5561dc78<br>*/<br>movq $0x59b997fa,%rdi<br>pushq$0x4017ec <br>ret<br><br></code></pre></td></tr></table></figure><h4 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h4><p>这题比前两题难许多，需要调用的是 touch3 函数，传入的是一个字符串而不是数值。一开始我的想法是，注入的代码中使用<code>pushq</code>将字符串对应的字节码入栈，但是 gcc 提示我：</p><blockquote><p>Error: operand type mismatch for &#96;push’</p></blockquote><p>尽管 q 后缀代表的就是 8byte，我还是发现只要是大于 4 个字节的内容都无法入栈，这个地方我还是没有明白，如果你知道可以评论解答一下。</p><p>后来我采取的策略是直接将字符串内容在注入时就写入，最终成功实现，思路如下。第一条指令将字符串的指针传入%rdi 中，算内存位置的时候仔细点，我前面错了好几次。后面的指令和上一题的相似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">/*<br>|<br>|-------------<br>| test()<br>| 0x08all instruction <br>|------<br>|    all hex cookie<br>| <br>|-------------  <br>| ret addr<br>|-------------push ret addr to touch3()<br>| getbuf()<br>| 0x28<br>*/<br>movq $0x5561dcb5,%rdi<br>pushq $0x4018fa<br>ret<br></code></pre></td></tr></table></figure><h3 id="ROP-Attack"><a href="#ROP-Attack" class="headerlink" title="ROP Attack"></a>ROP Attack</h3><p>书上讲了三种方式防止代码注入攻击，分别是栈随机化、栈破坏检测和限制可执行性区域，这些方法可以通过 ROP 攻击规避。ROP 攻击的主旨是寻找机器码中的<code>c3</code>也就是汇编中的<code>ret</code>, 以及它前面的一些特定的内容，将这些现存的代码作为攻击的工具 (gadget)。这些内容有些原本就是指令，有些原本只是常数，但是由于巧合，他们构成了一些可用的指令。</p><p>每一个 gadget 中都由<code>c3</code>结尾，因此只需要合理安排栈中的溢出内容，就可以在各个 gadget 间跳跃，从而能够用这些 gadget 构成一系列指令，让程序按照攻击者的意愿运行。</p><h4 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h4><p>这题只需要用 ROP 实现第二题的内容。首先栈上不可执行，因此在栈上写入 cookie 的内容后，需要通过特定的 gadget（popq 指令）将它传入%rdi 中。在 vim 中对 rtarget 的反汇编代码进行搜索，发现没有直接 pop 到%rdi 的 gadget，因此需要两步：先出栈到某个寄存器，再用某个 movq 的 gadget 将内容传入%rdi 中。思路如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">/*<br>|...<br>|---------- The instructions in stack are not executable. <br>|           So I can only write infomation in stack and  <br>| test()access them by gadgets.<br>| 0x8<br>|           -&gt;touch2 addr<br>|           -&gt;gadget2 addr (move)<br>|-----------&gt;cookie <br>| ret addr -&gt;gadget1 addr (popq)<br>|----------<br>| getbuf()<br>| 0x28<br>*/<br></code></pre></td></tr></table></figure><h4 id="Task-5"><a href="#Task-5" class="headerlink" title="Task 5"></a>Task 5</h4><p>这是选做题，主题思路一致，需要用 ROP 实现 Task3。暂时先不做了。</p><h3 id="一些用到的技术"><a href="#一些用到的技术" class="headerlink" title="一些用到的技术"></a>一些用到的技术</h3><h4 id="1-如何获得汇编代码的对应的十六进制机器码？"><a href="#1-如何获得汇编代码的对应的十六进制机器码？" class="headerlink" title="1. 如何获得汇编代码的对应的十六进制机器码？"></a>1. 如何获得汇编代码的对应的十六进制机器码？</h4><p>写下汇编代码后用<code>gcc -c xxx.s</code>编译。然后用<code>objdump -d xxx.o</code>反编译。</p><h4 id="2-vim-中的搜索，复制，黏贴指令。"><a href="#2-vim-中的搜索，复制，黏贴指令。" class="headerlink" title="2.vim 中的搜索，复制，黏贴指令。"></a>2.vim 中的搜索，复制，黏贴指令。</h4><p>复制：<code>v</code>进入视觉模式选择内容，<code>c</code>剪切<code>y</code>复制，<code>p</code>黏贴在光标，<code>P</code>黏贴在最后。</p><p>搜索： <code>/</code>后接搜索内容，回车后，<code>n</code>为下一个<code>N</code>为上一个。</p><h4 id="3-gdb-的图形界面指令。"><a href="#3-gdb-的图形界面指令。" class="headerlink" title="3.gdb 的图形界面指令。"></a>3.gdb 的图形界面指令。</h4><p>使用<code>tui enable</code>开启，<code>focus+类型</code>为聚焦位置 <code>layout+类型</code>为界面布局内容。</p><p>上述<code>类型</code>有：<code>asm</code>汇编代码窗口，<code>cmd</code>命令行窗口，<code>reg</code>寄存器窗口等等。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 boost.property_tree 解析带有数组的 JSON</title>
    <link href="/2020/08/18/boost-ptree-write-json-array/"/>
    <url>/2020/08/18/boost-ptree-write-json-array/</url>
    
    <content type="html"><![CDATA[<h2 id="property-tree-结构的简单分析"><a href="#property-tree-结构的简单分析" class="headerlink" title="property_tree 结构的简单分析"></a>property_tree 结构的简单分析</h2><p>如果要弄明白要如何将数组写入 json 中，需要大致了解 ptree 的结构组成，<br>我来简单讲讲。</p><p>ptree 是树状结构，由很多个节点组成，而每个节点都是由一个<code>std::pair</code>对象组成。每一个<code>std::pair</code>都由两个部分组成，分别可以由<code>pairName.first</code>,<code>pairName.second</code>指向，前者是一个字符串，也就是这个节点的名称，后者是一个<code>ptree</code>。从根节点开始，它的<code>first</code>就是这个节点的名，而它的<code>second</code>就是这个节点的子树，每个节点以此类推，直到到达树的叶子。而树的叶节点也是相同的<code>std::pair</code>对象，不同的是，它的<code>second</code>的<code>ptree</code>是一棵只有一个值的树，这也是后面生成带有数组的 json 时的重点。</p><h2 id="将对象写入-JSON-中"><a href="#将对象写入-JSON-中" class="headerlink" title="将对象写入 JSON 中"></a>将对象写入 JSON 中</h2><p>这个部分非常直接，boost 提供的接口可以直接将指定的值写入到指定的路径上。写入的函数有<code>put()</code>和<code>add()</code>两种，不同之处在于前者会替换原有路径上的值，而后者不会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">easyExample</span><span class="hljs-params">(pt::ptree &amp;pt)</span></span><br><span class="hljs-function"></span>&#123;<br>    pt.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;example.info&quot;</span>, <span class="hljs-string">&quot;an example of parsing json.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">badExample</span><span class="hljs-params">(pt::ptree &amp;pt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        pt.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;example.array&quot;</span>, <span class="hljs-string">&quot;string1&quot;</span>);<br>        pt.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;example.array&quot;</span>, <span class="hljs-string">&quot;string2&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;example&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;an example of parsing json.&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;array&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;array&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string2&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>可以看到这个结果中有同名的路径，而不是我们想做到的数组，所以是一个错误示范。</p><h2 id="将数组写入-JSON-中"><a href="#将数组写入-JSON-中" class="headerlink" title="将数组写入 JSON 中"></a>将数组写入 JSON 中</h2><p>在接下来的这个部分，最终生成的 json 如下，可以看到，其中有两种数组，分别是普通数组和对象数组。</p><h3 id="普通数组的写入"><a href="#普通数组的写入" class="headerlink" title="普通数组的写入"></a>普通数组的写入</h3><p>代码如下，首先声明一个 array 树，用<code>push_back()</code>将一个<code>std::pair</code>写入。正如前文所说，这是一个叶节点，它的 ptree 中只包含了一个值，而且根据 ptree 中对数组内元素的定义，它的名字是空的。array 树写入完成后，再用<code>add_child()</code>将 array 写入为 pt 的子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">writeInArray</span><span class="hljs-params">(pt::ptree &amp;pt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        pt::ptree array;<br>        array.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;&quot;</span>, pt::<span class="hljs-built_in">ptree</span>(<span class="hljs-string">&quot;string1&quot;</span>)));<br>        array.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;&quot;</span>, pt::<span class="hljs-built_in">ptree</span>(<span class="hljs-string">&quot;string2&quot;</span>)));<br>        pt.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;example.array&quot;</span>, array);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下，是正确的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;example&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;an example of parsing json.&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;array&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;string1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;string2&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="对象数组的写入"><a href="#对象数组的写入" class="headerlink" title="对象数组的写入"></a>对象数组的写入</h3><p>上一篇文章有提到，对象数组指的是内容是对象的数组。写入方法和上面大至相同，都是先构建好数组子树再将他插入树中。将名字为空的<code>std::pair</code>用<code>push_back()</code>写入是构建数组最关键的一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">writeInObjectArray</span><span class="hljs-params">(pt::ptree &amp;pt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        pt::ptree object1, object2, objectArray;<br>        object1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1-1&quot;</span>);<br>        object1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2-1&quot;</span>);<br>        object2.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1-2&quot;</span>);<br>        object2.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2-2&quot;</span>);<br>        objectArray.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;&quot;</span>, object1));<br>        objectArray.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;&quot;</span>, object2));<br>        pt.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;example.object array&quot;</span>, objectArray);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        cout &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>boost</tag>
      
      <tag>C++</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 boost.property_tree 解析带有数组的 JSON</title>
    <link href="/2020/08/17/boost-ptree-parse-json-array/"/>
    <url>/2020/08/17/boost-ptree-parse-json-array/</url>
    
    <content type="html"><![CDATA[<p>害，终于考完期末考了。接下来两个星期的实验一做完就大四了，而且近期还要备考雅思，可以说接下来一段时间也是很忙的。但是不管怎么说，先让自己休息两天吧。一开始我在想，两天的时间能写点什么呢，突然想起可以学一下 boost 里面的 ptree 库解析 json。之前写树莓派闹钟的时候用过 jsoncpp，那时候 c++ primer 才刚学一半，属实是心急了，弄了一个多星期才做出来，而且大多数时间都是在配环境，也不懂得看文档，现在码力提高了不少，算是很轻松的。</p><h2 id="初步学习解析-JSON"><a href="#初步学习解析-JSON" class="headerlink" title="初步学习解析 JSON"></a>初步学习解析 JSON</h2><p>需要用到的头文件主要是下面两个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;boost\property_tree\ptree.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;boost\property_tree\json_parser.hpp&quot;</span></span><br></code></pre></td></tr></table></figure><p>主体思路为：首先将 json 解析为 property_tree，然后就可以通过操作 property_tree 的接口获得数据。</p><p>以下面的 json 为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;example&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;an example of parsing json.&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;array&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;string1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;string2&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;object array&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;key1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1-1&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;key2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value2-1&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;key1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1-2&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;key2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value2-2&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>假如说我要输出这个文件中的”info“的值，简略的过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//read json file</span><br><span class="hljs-function">std::ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;./res/test.json&quot;</span>)</span></span>;<br><span class="hljs-comment">//create ptree</span><br>pt::ptree pt;<br><span class="hljs-comment">//parse json into ptree</span><br>pt::<span class="hljs-built_in">read_json</span>(fin, pt);<br><span class="hljs-comment">//use get() and point out the path of what you need.</span><br>cout &lt;&lt; pt.<span class="hljs-built_in">get</span>&lt;string&gt;(<span class="hljs-string">&quot;example.info&quot;</span>);<br></code></pre></td></tr></table></figure><p>这个内容非常简单，包括看文档，我就用了 15 分钟，但是接下来的问题花了我很多时间。</p><h2 id="踩坑：解析带有数组的-JSON"><a href="#踩坑：解析带有数组的-JSON" class="headerlink" title="踩坑：解析带有数组的 JSON"></a>踩坑：解析带有数组的 JSON</h2><p>在 boost 的文档中写道：</p><blockquote><p>JSON arrays are mapped to nodes. Each element is a child node with an empty name.</p></blockquote><p>那么现在的问题就转变为如何指向这些空名字的节点了，一开始我试了很多不同的方式，似乎都不能做到，最后就只能上 StackOverflow 看看了😂。</p><p>首先是单纯的数组，也就是上面 json 中的 array 项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">pt = pt.<span class="hljs-built_in">get_child</span>(<span class="hljs-string">&quot;example.array&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : pt.<span class="hljs-built_in">get_child</span>(<span class="hljs-string">&quot;&quot;</span>))<br>&#123;<br>    cout &lt;&lt; i.second.<span class="hljs-built_in">get_value</span>&lt;string&gt;();<br>&#125;    <br></code></pre></td></tr></table></figure><p>整个过程首先要获得”array”为根的子树，然后使用容器遍历元素的方法，遍历所有 array 的子节点。在 ptree 中，每个节点都是 pair，也就是由键值对组成，因此<code>i.first</code>就是子节点的键，类型为字符串，它是空的。而<code>i.second</code>就是它的值，也是一棵 ptree。因为我们已经知道<code>i.second</code>就是一棵只有一个值的 ptree，因此只需通过 ptree 的 get_value() 函数就可以得到它。</p><p>下面对对象数组解析，这个数组中每个元素都是对象，也就是上面的”object array”项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">pt = pt.<span class="hljs-built_in">get_child</span>(<span class="hljs-string">&quot;example.object array&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : pt.<span class="hljs-built_in">get_child</span>(<span class="hljs-string">&quot;&quot;</span>))<br>&#123;<br>    cout &lt;&lt; i.second.<span class="hljs-built_in">get</span>&lt;string&gt;(<span class="hljs-string">&quot;key1&quot;</span>)     <br>&#125;<br></code></pre></td></tr></table></figure><p>与上面过程不同的是，<code>i.second</code>不是一个值而是一个有子节点的 ptree，因此我们通过 ptree 的 get() 函数获得它的子节点的值。如上代码可以得到<code>value1-1</code>和<code>value1-2</code></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>boost</tag>
      
      <tag>C++</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量类遍历操作接口踩坑实录——函数对象</title>
    <link href="/2020/06/12/traverse-interface-with-functor/"/>
    <url>/2020/06/12/traverse-interface-with-functor/</url>
    
    <content type="html"><![CDATA[<p>前几天学校终于通知返校时间了，8 月份小学期，返校考试。我还是很享受这段在家自学的时间的，毕竟对本专业已经完全失去任何热情，在家还能有充足的时间自学，给以后转行铺路。前段时间刚写完一个用 openCV 识别方格扫雷的代码，花了好多时间，效果也还行，至少算是自己给自己布置的《c++ primer plus》结课作业。上周很忙的肝完了一个 pre，两篇学术垃圾，终于有时间继续写代码了，就找了清华邓俊辉老师的数据结构资料开始自学。我的计划大概是，这段时间里到开始期末复习和准备雅思之前，能学多少就学多少吧，然后一遍学，一边跟着把各种数据结构实现一下。</p><p>这篇文章主要写一下实现遍历接口的时候踩到坑。主要是关于如何通过函数对象实现遍历接口。</p><h2 id="函数对象是什么"><a href="#函数对象是什么" class="headerlink" title="函数对象是什么"></a>函数对象是什么</h2><p>如果我没有理解错的话，函数对象就是仿函数（functor）, 它是通过在类中包装一个<code>()</code>的运算符重载函数，实现“看起来像个函数的效果”。<del>如果它长得像鸭子，叫声像鸭子，走路也像鸭子，那它就是鸭子。</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;duck\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo foo;<br>    <span class="hljs-built_in">foo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大概就是上面这样。</p><h2 id="通过函数对象特性实现遍历接口"><a href="#通过函数对象特性实现遍历接口" class="headerlink" title="通过函数对象特性实现遍历接口"></a>通过函数对象特性实现遍历接口</h2><p>下面是书上提供的遍历接口和传入函数对像实现的代码。例子中传入一个“加一”仿函数，用来遍历给每个元素都++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Traverse interface.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt;<br><span class="hljs-type">void</span> MyVector&lt;T&gt;::<span class="hljs-built_in">traverse</span>(VST &amp;visit)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size; i++)<br>        <span class="hljs-built_in">visit</span>(_elem[i]);<br>&#125;<br><span class="hljs-comment">// Functor.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AndOne</span> <span class="hljs-comment">// Structure is similar with class.</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T &amp;e)</span> </span>&#123; e++; &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">andOne</span><span class="hljs-params">(MyVector&lt;T&gt; &amp;v)</span></span><br><span class="hljs-function"></span>&#123;<br>    v.<span class="hljs-built_in">traverse</span>(<span class="hljs-built_in">andOne</span>&lt;T&gt;());<br>&#125;<br><span class="hljs-comment">// Usage.</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyVector&lt;<span class="hljs-type">int</span>&gt; MV = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-built_in">andOne</span>(MV); <span class="hljs-comment">// All element ++.</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而用这个书上的代码编译器是会报错的，显示：</p><p><code>     &quot;cannot bind non-const lvalue reference of type &#39;IncreaseOne&lt;int&gt;&amp;&#39; to an rvalue of type &#39;IncreaseOne&lt;int&gt;&#39;&quot;</code>。</p><p>意思是不能将非常量左值的引用和右值绑定。我觉得应该是因为在<code>andOne</code>函数里，并没有创建一个结构体。也就是说，并没有通过左值传递，而是只创建了一个右值，然而右值是没有办法修改的，函数中又没有使用 const 关键字，最后编译器就报错了。</p><p>解决的方法有两个，第一个就是直接把&amp;去掉，直接通过<code>traverse(VST)</code>按值传递。另一个办法就是采用右值引用，也就是<code>traverse(VST&amp;&amp;)</code>。这是 c++11 的内容，可能老师在写这本书的时候还没有这个标准吧。</p><p>我刚开始折腾了很久也想到为什么，我还以为是其他的地方出错了，整个头文件看了好几遍，查也查不到。最后准备去 Stackoverflow 上提问，没想到查到了有人问过这个问题，然后就解决了~</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>函数对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus 第 13 章知识点</title>
    <link href="/2020/05/11/cpp-primer-plus-chapter-13/"/>
    <url>/2020/05/11/cpp-primer-plus-chapter-13/</url>
    
    <content type="html"><![CDATA[<h2 id="派生一个类"><a href="#派生一个类" class="headerlink" title="派生一个类"></a>派生一个类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rating;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RatedPlayer</span> (...);  <span class="hljs-comment">//constructor</span><br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">Rating</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> rating;&#125; <span class="hljs-comment">//a derived class method</span><br>&#125;<br></code></pre></td></tr></table></figure><p>声明头表示 TableTennisPlayer 是一个公有基类，这个派生类是公有派生。TTP 基类的公有成员会成为 RP 派生类的公有成员。基类的私有部分也是派生类的一部分，但是要通过基类的公有函数来访问。</p><p>派生类的构造函数需要给新成员和继承的成员都提供数据。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">RatedPlayer::<span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string&amp; fn, <span class="hljs-type">const</span> string&amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到基类的对象在进入构造函数之前被构造，如果不显式调用基类的构造函数，则会自动隐式调用默认的基类构造函数<code>TableTennisPlayer()</code></p><h3 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h3><p>派生类可以使用基类的公有方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">RatedPlayer rp1;<br>rp1.<span class="hljs-built_in">Name</span>();  <span class="hljs-comment">//Name() is a method of TableTennisPlayer class.</span><br></code></pre></td></tr></table></figure><p>基类指针可以在不进行显示类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">RatedPlayer rp1;<br>TableTennisPlayer* p1 = rp1;<br>TableTennisPlayer&amp; p2 = rp1;<br>p1-&gt;<span class="hljs-built_in">Name</span>();<br>p2.<span class="hljs-built_in">Name</span>();<br></code></pre></td></tr></table></figure><p>但是它们只能使用基类的方法，不能使用派生类的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p1-&gt;<span class="hljs-built_in">Rating</span>();  <span class="hljs-comment">//invalid!</span><br></code></pre></td></tr></table></figure><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>如果希望使用与基类不同的定义，则需要在派生类中声明和定义不同的函数版本。如果定义时没有使用<code>virtual</code>关键字，程序根据引用类型或者指针类型来选择方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Brass dom;  <span class="hljs-comment">//base class</span><br>BrassPlus dot;  <span class="hljs-comment">//derived class</span><br>Brass&amp; b1 = dom;<br>Brass* b2 = dot;<br>b1.<span class="hljs-built_in">ViewAcct</span>();<br>b2-&gt;<span class="hljs-built_in">ViewAcct</span>();  <span class="hljs-comment">//both of them invoke Brass::ViewAcct()</span><br><span class="hljs-comment">//because b1 and b2 is Brass&amp;</span><br></code></pre></td></tr></table></figure><p>如果使用<code>virtual</code>关键字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//....</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span></span>; <br><span class="hljs-comment">//....</span><br>Brass dom;  <span class="hljs-comment">//base class</span><br>BrassPlus dot;  <span class="hljs-comment">//derived class</span><br>Brass&amp; b1 = dom;<br>Brass* b2 = dot;<br>b1.<span class="hljs-built_in">ViewAcct</span>();  <span class="hljs-comment">//invoke Brass::ViewAcct()</span><br>b2-&gt;<span class="hljs-built_in">ViewAcct</span>();  <span class="hljs-comment">//invoke BrassPlus::ViewAcct()  </span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 记得在两个类中使用 virtual 声明析构虚函数。</p><h3 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h3><p>首先，虚函数应该与原本的原型完全相同，如果返回类型是基类引用或者指针，则可以改变为指向派生类的引用或指针。</p><p>其次，如果类声明被重载了，则应该在派生类中重新定义所有基类的版本。</p><h2 id="“protected-”访问控制"><a href="#“protected-”访问控制" class="headerlink" title="“protected:”访问控制"></a>“protected:”访问控制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Brass</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">double</span> balance;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于外部而言，<code>protected:</code>中的类成员是私有的，对于派生类来说，它是公共的。</p><p>最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类的方法使派生类间接访问数据。对于成员函数来说，保护访问很有用，能让派生类访问公众不能访问的内部函数。</p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>有时两个累不具有“is-a”规则，也就是两者有共性，但又有不同之处，可以抽象出他们的共性，将这些共性放到一个抽象基类中（abstract base class, ABC），再派生出这两个类。</p><p>在 ABC 中有一些方法，可能还没包含必要的数据成员来声明。C++通过使用纯虚函数提供未实现的函数。纯虚函数在开图使用<code>virtual</code>，并在末尾使用<code>= 0</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseEllipse</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">Area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// a pure virtual function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要该类中包含了至少一个纯虚函数，则不能创建该类的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">BaseEllipse a;<span class="hljs-comment">// invalid!!</span><br></code></pre></td></tr></table></figure><p>纯虚函数可以有定义，也可以不定义。纯虚函数在派生类中必须有强制替代项，而普通虚函数可以没有。</p><p>从 ABC 类派生出的类可以用 ABC 类的指针同时管理，这些类被称作具体类（concrete class）</p><h2 id="继承和动态内存分配"><a href="#继承和动态内存分配" class="headerlink" title="继承和动态内存分配"></a>继承和动态内存分配</h2><h3 id="一、派生类不使用-new"><a href="#一、派生类不使用-new" class="headerlink" title="一、派生类不使用 new"></a>一、派生类不使用 new</h3><p>此时派生类不需要定义显式的析构函数、复制构造函数和赋值运算符。</p><h3 id="二、派生类使用-new"><a href="#二、派生类使用-new" class="headerlink" title="二、派生类使用 new"></a>二、派生类使用 new</h3><p>首先，派生类析构函数会自动调用基类的析构函数，其自身只需要完成派生类构造函数的清理工作。</p><p>其次，复制构造函数需要定义深复制，派生类只能访问基类的公有部分，因此还要在复制构造函数中调用基类的复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">baseDMA::<span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> baseDMA&amp; rs)<br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br>hasDMZ::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> hasDMA&amp; rs) : <span class="hljs-built_in">baseDMA</span>(hs)<span class="hljs-comment">// 基类引用可以指向派生类，hs 不需要类型转换</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后，赋值运算符和上面类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">hasDMA&amp; hasDMA::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> hasDMA&amp; hs)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;hs)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    baseDMZ::<span class="hljs-keyword">operator</span>=(hs);  <span class="hljs-comment">//copy the base portion</span><br>    <span class="hljs-keyword">delete</span>[] style;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(hs.style) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, hs.style);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="友元的继承"><a href="#友元的继承" class="headerlink" title="友元的继承"></a>友元的继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//基类声明</span><br><span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> baseDMA&amp; rs);<br><span class="hljs-comment">//派生类声明</span><br><span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> lacksDMA&amp; rs);<br><span class="hljs-comment">//基类定义</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> baseDMA&amp; rs)<br>&#123;<br>    os &lt;&lt; <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-comment">//派生类定义</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> lacksDMA&amp; rs)<br>&#123;<br>    os &lt;&lt; (<span class="hljs-type">const</span> baseDMA&amp;) ls;<br>    os &lt;&lt; <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类无法直接访问基类的数据，所以在其中先调用了基类的函数。另外，由于友元函数不是成员函数，无法通过解析作用域运算符来指定使用的函数，所以只能进行显式的转换。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus 第 12 章知识点</title>
    <link href="/2020/05/08/cpp-primer-plus-chapter-12/"/>
    <url>/2020/05/08/cpp-primer-plus-chapter-12/</url>
    
    <content type="html"><![CDATA[<h2 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h2><p>这些函数是自动定义的，定义的情况如下：</p><ol><li>默认构造函数，如果没有定义构造函数；</li><li>默认析构函数，如果没有定义；</li><li>复制构造函数，如果没有定义；</li><li>赋值运算符，如果没有定义；</li><li>地址运算符，如果没有定义。</li></ol><h3 id="构造和析构函数"><a href="#构造和析构函数" class="headerlink" title="构造和析构函数"></a>构造和析构函数</h3><p>如果使用<code>new</code>在构造函数中分配内存，则必须在析构函数中使用<code>delete</code>将其删除。</p><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Class_name</span> (<span class="hljs-type">const</span> Class_name&amp;);<br></code></pre></td></tr></table></figure><p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都会被调用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">StringBad <span class="hljs-title">ditto</span><span class="hljs-params">(motto)</span></span>;<br>StringBad metoo = motto;<br>StringBad also = <span class="hljs-built_in">stringBad</span>(motto);<br>StringBad* pStringBad = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBad</span>(motto);<br></code></pre></td></tr></table></figure><p>按值传递对象将调用复制构造函数，因此应该按引用传递对象，以减少使用的时间和空间。</p><h3 id="默认复制构造函数带来的问题和解决"><a href="#默认复制构造函数带来的问题和解决" class="headerlink" title="默认复制构造函数带来的问题和解决"></a>默认复制构造函数带来的问题和解决</h3><p>默认复制构造函数会对非静态成员逐个进行<code>浅复制</code>，复制的是成员的地址，即两个对象的成员都是同一个地址的数据。如果在析构函数中有对内存的释放，则会导致同一内存空间被释放两次！<br><img src="/img/post5/post5-1.jpg"><br>解决的方法则是定义一个显式的复制构造函数，并定义它进行深度复制（deep copy）。也就是，复制时先将数据复制到新的地址，而成员指向新的地址而不是同一地址。<br><img src="/img/post5/post5-2.jpg"></p><p><strong>总而言之，如果类中包含了 new 初始化的成员，应当定义一个使用深度复制的复制构造函数</strong></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>C++允许类对象赋值，通过自动为类重载赋值运算符实现的，它的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Class_name&amp; Class_name::<span class="hljs-keyword">operator</span>=(cosnt Class_name&amp;);<br></code></pre></td></tr></table></figure><p>默认的隐式赋值运算符重载，会使用软复制。它和上面的复制构造函数类似，也有不同点：</p><ul><li>目标对象原有的数据要用 delete 先释放。</li><li>应当避免赋值给自身，否则在赋值前释放内存可能会删除对象的内容。</li><li>返回一个指向对象的引用。</li></ul><p>下面是一个赋值运算符重载的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">StringBad&amp; StringBad::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StringBad&amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <span class="hljs-comment">//#1 先判断是否自我赋值，如果地址相同，直接返回。</span><br>    delect [] str;    <span class="hljs-comment">//将原本指向的位置释放，否则那里的内存将浪费。</span><br>    len = st.len;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy_s</span>(str, st.str);  <span class="hljs-comment">//新分配内存，并指向内存</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造函数中使用-new-的总结"><a href="#构造函数中使用-new-的总结" class="headerlink" title="构造函数中使用 new 的总结"></a>构造函数中使用 new 的总结</h2><ul><li>如果在构造函数中使用 new，则应在析构函数中使用 delete。</li><li>new 对应 delete，new[] 对应 delete[]。</li><li>如果有多个构造函数，要用同一个方式使用 new。</li><li>如果构造函数使用了 new，应当显式定义复制构造函数，并使用深度复制。</li><li>赋值运算符同上。</li></ul><h2 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h2><p>应注意以下：</p><ul><li>声明方式与常规一致</li><li>可以初始化为指向已有对象</li><li>使用 new 时会调用相应的类构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">String* a = <span class="hljs-keyword">new</span> String;  <span class="hljs-comment">//default constructor</span><br>String* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abcde&quot;</span>);  <span class="hljs-comment">// use String(const char*) constructor </span><br>String* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(b) <span class="hljs-comment">//b is an object, use copy constructor</span><br></code></pre></td></tr></table></figure></li><li>使用-&gt;运算符访问类</li><li>使用*运算符解除引用来获得对象</li></ul><h3 id="定位-new-运算符"><a href="#定位-new-运算符" class="headerlink" title="定位 new 运算符"></a>定位 new 运算符</h3><p>如果先用 new 分配一个内存块，再将类用定位 new 运算符存入，不能只 delete 该内存块，还要显式调用该类对象的析构函数，这是少数要显式调用析构函数的情况之一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">512</span>];<br>String* pc1 = <span class="hljs-built_in">new</span>(buffer) <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">//....</span><br>pc1-&gt;~<span class="hljs-built_in">String</span>();  <span class="hljs-comment">//destroy object pointed to pc1</span><br><span class="hljs-keyword">delete</span>[] buffer;  <span class="hljs-comment">//free buffer</span><br></code></pre></td></tr></table></figure><p>##成员列表初始化<br>如果再类中使用<code>const</code>声明了一个常量，但是在声明时没有初始化，则在调用构造函数时也无法给其赋值，因为在进入构造函数体之前，它已经被分配内存了。这个时候就需要使用成员列表初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">Queue::<span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> qs) : <span class="hljs-built_in">qsize</span>(qs)<br>&#123;<br>    front = rear = <span class="hljs-literal">NULL</span>;<br>    item = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//冒号后面就是成员列表初始化</span><br>Queue::<span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> qs) : <span class="hljs-built_in">qsize</span>(qs) : <span class="hljs-built_in">front</span>(<span class="hljs-literal">NULL</span>) : <span class="hljs-built_in">rear</span>(<span class="hljs-literal">NULL</span>) : <span class="hljs-built_in">item</span>(<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><span class="hljs-comment">//不是常量也可以使用该方式</span><br></code></pre></td></tr></table></figure><p>只有构造函数有以上性质，对于变量来说，上下两种没有太大的区别，但是</p><h2 id="用单向链表实现队列类"><a href="#用单向链表实现队列类" class="headerlink" title="用单向链表实现队列类"></a>用单向链表实现队列类</h2><p>单项链表中每个节点储存自己的数据，还储存了指向下一个节点的指针。队列类中储存指向链表头尾的指针。</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Queue::enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> Item&amp; item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isfull</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//队列满员退出</span><br>    Node* add = <span class="hljs-keyword">new</span> Node;  <span class="hljs-comment">//创建新节点</span><br>    add-&gt;item = item;<br>    add-&gt;next = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//给新节点赋值，并设定空指针</span><br>    items++；  <span class="hljs-comment">//队列成员增加</span><br>    <span class="hljs-keyword">if</span>(front == <span class="hljs-literal">nullptr</span>)<br>        front = add;  <span class="hljs-comment">//如果队列为空，将新的节点放到队列头</span><br>    <span class="hljs-keyword">else</span><br>        rear-&gt;next = add;  <span class="hljs-comment">//将当前链表尾巴的 next 指针指向新的节点</span><br>    rear = add;  <span class="hljs-comment">//将队列尾指针移动到链表尾</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Queue::dequeue</span><span class="hljs-params">(Item&amp; item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//队列空退出</span><br>    item = front-&gt;item;  <span class="hljs-comment">//将链表头的内容赋值给 item</span><br>    item--;  <span class="hljs-comment">//节点数减一</span><br>    Node* temp = front;  <span class="hljs-comment">//将 temp 指针指向当前头部的数据，用于接下来删除</span><br>    front = front-&gt;next;<span class="hljs-comment">//将指向头部的指针向后移动，相当于是下一项变成了头部</span><br>    <span class="hljs-keyword">delete</span> temp;  <span class="hljs-comment">//删除刚才的头部</span><br>    <span class="hljs-keyword">if</span> (items == <span class="hljs-number">0</span>)<br>        rear = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">//如果此时节点数为零，则将队列尾指针设为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><code>dequeue()</code>可以清楚节点，但是不能保证队列到期后为空，因此需要一个显式析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">Queue::~<span class="hljs-built_in">Queue</span>()<br>&#123;<br>    Node* temp;<br>    <span class="hljs-keyword">while</span> (front != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//当队列不为空</span><br>    &#123;<br>        temp = front;<br>        front = front-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;  <span class="hljs-comment">//原理和出队类似</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外析构的问题还会导致赋值运算符和复制构造函数出错，原理与之前类似，只能通过显式定义的函数来解决，如果不需要用到这些功能，可以将这两个函数声明到私有方法中。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus 第 11 章知识点</title>
    <link href="/2020/05/07/cpp-primer-plus-chapter-11/"/>
    <url>/2020/05/07/cpp-primer-plus-chapter-11/</url>
    
    <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="声明、定义和使用运算符重载"><a href="#声明、定义和使用运算符重载" class="headerlink" title="声明、定义和使用运算符重载"></a>声明、定义和使用运算符重载</h3><p>运算符重载将重载的概念拓展到运算符上，允许 C++运算符被赋予多种含义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在头文件声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span>:<br>   Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> <span class="hljs-type">double</span> t) <span class="hljs-type">const</span>; <br>&#125;<br><span class="hljs-comment">//在实现文件中定义</span><br>Time::Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> <span class="hljs-type">double</span> t) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">//由 Time 对象调用，以一个 Time 类型对象的引用为参数，返回一个 Time 类型的对象</span><br>A = B.<span class="hljs-keyword">operator</span>*(C);<br>A = B * C;<br></code></pre></td></tr></table></figure><h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><ol><li>至少有一个操作数为用户定义类型</li><li>不能违反运算符原来的句法规则，不能修改运算符的优先级。</li><li>不能创建新的运算符</li><li>不能重载<code>sizeof</code>、<code>.</code>、<code>.*</code>、<code>::</code>、<code>?:</code>、<code>typeid</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret</code>、<code>static_cast</code>运算符。</li><li>尽量符合逻辑，否则尽量用名称有说明性的类方法如<code>swap()</code>。</li></ol><h3 id="单个操作数的重载"><a href="#单个操作数的重载" class="headerlink" title="单个操作数的重载"></a>单个操作数的重载</h3><p>下面是给向量取负值的运算符重载示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明</span><br>Vector <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span>;<br><span class="hljs-comment">//定义</span><br>Vector <span class="hljs-keyword">operator</span>-() cosnt<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(-x, -y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。如上运算符重载的例子，如果将两个操作数调换，则会出错，因为 fixing 是 double 类的对象而不是 time 的对象。</p><h3 id="声明、定义和使用友元"><a href="#声明、定义和使用友元" class="headerlink" title="声明、定义和使用友元"></a>声明、定义和使用友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头文件声明</span><br><span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>* (<span class="hljs-type">double</span> m, <span class="hljs-type">const</span> time&amp; t);<br><span class="hljs-comment">//定义，它不是成员函数，不用“Time：”。</span><br>Time <span class="hljs-keyword">operator</span>* (<span class="hljs-type">double</span> m, <span class="hljs-type">const</span> time&amp; t)<br>&#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">//使用</span><br>A = <span class="hljs-keyword">operator</span>*(C, B);<br>A = C * B;<br></code></pre></td></tr></table></figure><h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><p>自动转换（automatic conversion）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">3.33</span>;<br></code></pre></td></tr></table></figure><p>强制转换（type cast）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* a = (<span class="hljs-type">int</span>*) <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><h4 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h4><p>只接受一个参数的构造函数可以作为转换函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Stone</span> (<span class="hljs-type">double</span> lbs);  <span class="hljs-comment">//构造函数声明</span><br><br>Stone myCat;<br>myCat = <span class="hljs-number">16.9</span>;  <span class="hljs-comment">//自动将 int 隐式转换成 Stone</span><br></code></pre></td></tr></table></figure><p>如果不希望自动隐式转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stone</span> <span class="hljs-params">(<span class="hljs-type">double</span> lbs)</span></span>;  <span class="hljs-comment">//no implicit conversions allowed!!</span><br></code></pre></td></tr></table></figure><p>多参数的构造函数如果后面的参数全部设定默认值，也自动隐式转换。下面有更进一步的转换演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Stone&amp; st, <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">//声明</span><br><span class="hljs-built_in">display</span>(<span class="hljs-number">122</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">//编译器先寻找 Stone(int) 的构造函数，因为 122 是 int 类型。</span><br><span class="hljs-comment">//没有找到，编译器开始寻找接受其他类型的构造函数，找到了 Stone(double)。</span><br><span class="hljs-comment">//编译器将 int 转换成 double，再传递给 display()。</span><br></code></pre></td></tr></table></figure><h4 id="转换函数-1"><a href="#转换函数-1" class="headerlink" title="转换函数"></a>转换函数</h4><p>使用特殊的 C++运算符函数——转换函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">typeName</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//如</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">//声明</span><br><br><span class="hljs-function">Stone::<span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//定义</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span> (pounds + <span class="hljs-number">0.5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>转换函数必须是类方法</li><li>转换函数不能返回值</li><li>转换函数不能有参数</li></ul><p>虽然没有声明返回类型，但是这个函数会返回所需的值。强制显式转换的方法和转换构造函数相同。</p><h2 id="转换函数和友元函数"><a href="#转换函数和友元函数" class="headerlink" title="转换函数和友元函数"></a>转换函数和友元函数</h2><p>前面提到，由于乘法运算可能两个操作数只有一个是用户定义类型的对象，只有乘法运算的运算符重载使用友元函数，才可以调换两个操作数的顺序。<br>而对于加法，一般两个操作数是同一类型，则不需要使用友元函数。</p><p>但是，如果定义了转换函数，只有使用友元函数运算服重载才能让前面的操作数进行隐式的自动转换。然而，为了更保险，可以强制使用显式转换，在转换函数的声明前加上保留字<code>explicit</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus 第 10 章知识点</title>
    <link href="/2020/05/05/cpp-primer-plus-chapter-10/"/>
    <url>/2020/05/05/cpp-primer-plus-chapter-10/</url>
    
    <content type="html"><![CDATA[<h2 id="指定类的设计"><a href="#指定类的设计" class="headerlink" title="指定类的设计"></a>指定类的设计</h2><h3 id="第一步，提供类声明"><a href="#第一步，提供类声明" class="headerlink" title="第一步，提供类声明"></a>第一步，提供类声明</h3><p>类声明可以包括数据成员和函数成员。声明私有部分只能通过成员函数访问；公共部分的成员可以直接被使用类对象的程序直接访问。一般来讲，数据成员放在私有部分，成员函数放在共有部分。典型声明结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//data member declarations</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//member function declarations</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="第二步，实现类成员函数"><a href="#第二步，实现类成员函数" class="headerlink" title="第二步，实现类成员函数"></a>第二步，实现类成员函数</h3><p>类声明中提供完整的函数定义是合法的（函数内容很小的情况下适用），但通常做法是单独提供函数定义。这种情况下，需要域解析运算符指出成员函数所属类。函数头示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">Bozo::Retort</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><h3 id="构造函数（constructor）"><a href="#构造函数（constructor）" class="headerlink" title="构造函数（constructor）"></a>构造函数（constructor）</h3><p>构造函数用于初始化或赋值&#x2F;如果没有提供构造函数，C++会自动提供默认的构造函数。如果想声明和定义构造函数，操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在类的头文件中声明</span><br><span class="hljs-built_in">Stock</span>(<span class="hljs-type">const</span> string&amp; company, <span class="hljs-type">long</span> shares, <span class="hljs-type">double</span> share_val);<br><span class="hljs-comment">//在实现文件中定义</span><br>Stock::<span class="hljs-built_in">Stock</span>(<span class="hljs-type">const</span> string&amp; company, <span class="hljs-type">long</span> shares, <span class="hljs-type">double</span> share_val)<br>&#123;<br>    <span class="hljs-comment">//为类成员赋值初始化</span><br>&#125;<br><span class="hljs-comment">//构造函数没有返回值，也不需要 void 关键字，同时名称与类名称相同。</span><br><span class="hljs-comment">//上述参数如 company 等，不是类成员，而是赋给类成员的值，因此名称不能和类成员相同。</span><br><span class="hljs-comment">//常见做法：给类成员命名时使用“m_”前缀或者“_”后缀。如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    string m_company;<br>    <span class="hljs-comment">//sting company_;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数，因此要自行定义。有两种方法：为已有的构造函数提供默认值；函数重载定义另一个构造函数。</p><p>关于如何使用构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Stock food = <span class="hljs-built_in">Stock</span>(<span class="hljs-string">&quot;World Cabbage&quot;</span>, <span class="hljs-number">250</span>, <span class="hljs-number">1.25</span>);<br><span class="hljs-function">Stock <span class="hljs-title">food</span> <span class="hljs-params">(<span class="hljs-string">&quot;World Cabbage&quot;</span>, <span class="hljs-number">250</span>, <span class="hljs-number">1.25</span>)</span></span>;<br><span class="hljs-comment">//c++11 列表初始化</span><br>Stock food = &#123;<span class="hljs-string">&quot;World Cabbage&quot;</span>, <span class="hljs-number">250</span>, <span class="hljs-number">1.25</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="析构函数（destructor）"><a href="#析构函数（destructor）" class="headerlink" title="析构函数（destructor）"></a>析构函数（destructor）</h3><p>析构函数用于清理工作。如果构造函数使用 new 分配内存，则析构函数使用 delete。上述如果没有使用 new，析构函数没有需要完成的任务，此时编译器会生成一个隐式析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//原型</span><br>~<span class="hljs-built_in">Stock</span>();<br><span class="hljs-comment">//定义</span><br>Stock::~<span class="hljs-built_in">Stock</span>()<br>&#123;<br>    <span class="hljs-comment">//如果构造函数使用 new，则需要用 delete 删除内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数的调用由编译器完成，通常不会显式调用。</p><h2 id="Const-成员函数"><a href="#Const-成员函数" class="headerlink" title="Const 成员函数"></a>Const 成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Stock land;<br></code></pre></td></tr></table></figure><p>创建了 const 的成员后，即使是成员函数也无法调用，因为编译器无法判断成员函数是否会修改 land 成员的内容。因此需要一个语法保证函数不会修改调用对象。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">//promises not to change invoking object</span><br><span class="hljs-comment">//定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stock::show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;&#125;  <span class="hljs-comment">//promises not to change invoking object</span><br></code></pre></td></tr></table></figure><h2 id="This-指针"><a href="#This-指针" class="headerlink" title="This 指针"></a>This 指针</h2><p>如果想要对比两个对象的成员，可以将对象 2 的成员作为参数传递给对象 1 的成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//定义</span><br><span class="hljs-function"><span class="hljs-type">const</span> Stock&amp; <span class="hljs-title">Stock::myFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> Stock&amp; s)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(xxxx) <br>        <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ??? <br>&#125;<br><span class="hljs-comment">//调用</span><br>Stock1.<span class="hljs-built_in">myFunction</span>(Stock2);<br><span class="hljs-comment">//显式访问 Stock2 的成员，隐式访问 Stock1 的成员，都有权限。</span><br></code></pre></td></tr></table></figure><p>上面的例子可以返回 stock2 的成员，但是无法返回 stock1 的成员，因为无法称呼。因此出现了<code>this</code>指针。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> Stock&amp; <span class="hljs-title">Stock::myFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> Stock&amp; s)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(xxxx) <br>        <span class="hljs-keyword">return</span> s;<br>      <span class="hljs-comment">//return s.member;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">//这个是返回 Stock1 对象 </span><br>      <span class="hljs-comment">//return this-&gt;member;</span><br>&#125;<br>Stock1.<span class="hljs-built_in">myFunction</span>(Stock2);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus 第 9 章知识点</title>
    <link href="/2020/05/03/cpp-primer-plus-chapter-9/"/>
    <url>/2020/05/03/cpp-primer-plus-chapter-9/</url>
    
    <content type="html"><![CDATA[<h2 id="变量的储存方式"><a href="#变量的储存方式" class="headerlink" title="变量的储存方式"></a>变量的储存方式</h2><table><thead><tr><th align="center">储存描述</th><th align="center">持续性</th><th align="center">作用域</th><th align="center">链接性</th><th align="center">如何声明</th></tr></thead><tbody><tr><td align="center">自动</td><td align="center">自动</td><td align="center">代码块</td><td align="center">无</td><td align="center">在代码块中</td></tr><tr><td align="center">寄存器</td><td align="center">自动</td><td align="center">代码块</td><td align="center">无</td><td align="center">在代码块中，使用关键字 register</td></tr><tr><td align="center">静态，无链接性</td><td align="center">静态</td><td align="center">代码块</td><td align="center">无</td><td align="center">在代码块中，使用关键字 static</td></tr><tr><td align="center">静态，外部链接性</td><td align="center">静态</td><td align="center">文件</td><td align="center">外部</td><td align="center">不在任何函数内</td></tr><tr><td align="center">静态，内部链接性</td><td align="center">静态</td><td align="center">文件</td><td align="center">内部</td><td align="center">不在任何函数内，使用关键字 static</td></tr></tbody></table><h3 id="持续性"><a href="#持续性" class="headerlink" title="持续性"></a>持续性</h3><p>持续性决定了数据保存在内存中的时间。<strong>自动储存持续性</strong>指数据在开始执行其所属的函数或代码块时创建，代码块或函数执行完毕后，内存释放；<strong>静态储存持续性</strong>在程序执行的整个期间都存在；<strong>线程储存持续性</strong>指用<code>thread_local</code>声明的变量，生命周期与所属线程一样长；<strong>动态储存持续性</strong>指用<code>new</code>分配的内存一直存在，直到使用<code>delete</code>将其释放。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域（scope）描述名称在文件的多大范围内可见。代码块指<code>&#123;&#125;</code>中间。</p><h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>链接性（linkage）描述名称如何在不同单元内共享。链接性为外部则可在文件间共享，为内部则只能在文件内部的函数中共享。如果无链接性则不能共享。</p><h2 id="名称空间指导原则"><a href="#名称空间指导原则" class="headerlink" title="名称空间指导原则"></a>名称空间指导原则</h2><ul><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++ 当前提倡将标准函数库放在名称空间 std 中，这种做法扩展到了来自 C 语言中的函数。例如，头文件 math.h 是与 C 语言兼容的，没有使用名称空间，但 C++ 头文件 cmath 应将各种数学库函数放在名称空间 std 中。</li><li>仅将编译指令 using 作为一种将陈旧代码转换为使用名称空间的权宜之计。</li><li>不要在头文件中使用 using 编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用 using 编译指令，应将其放在所有预处理器编译指令 #include 之后。</li><li>导入名称时，首选使用作用域解析操作符或 using 声明的方法。</li><li>对于 using 声明，首先将其作用域设置为局部而不是全局。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus 第 8 章知识点</title>
    <link href="/2020/05/02/cpp-primer-plus-chapter-8/"/>
    <url>/2020/05/02/cpp-primer-plus-chapter-8/</url>
    
    <content type="html"><![CDATA[<h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><h3 id="引用变量的使用"><a href="#引用变量的使用" class="headerlink" title="引用变量的使用"></a>引用变量的使用</h3><p>创建引用变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;  <br><span class="hljs-type">int</span>&amp; y = x；  <br><span class="hljs-comment">//y 是指向 int 类型的 x 的引用</span><br><span class="hljs-comment">//它们指向相同的值和内存单元</span><br></code></pre></td></tr></table></figure><p>按引用传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunction</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>返回引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">MyFunction</span><span class="hljs-params">()</span>；</span><br></code></pre></td></tr></table></figure><h3 id="返回引用注意事项"><a href="#返回引用注意事项" class="headerlink" title="返回引用注意事项"></a>返回引用注意事项</h3><p><strong>避免返回函数中止后不再存在的内存单元的引用</strong>，解决方法：</p><ol><li>返回一个作为参数传递给函数的引用</li><li>使用 new 分配储存空间</li></ol><h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><ul><li>能修改调用函数中的数据对象</li><li>传递引用而不是整个数据对象，提高程序运行速度</li></ul><h4 id="传递引用的指导准则"><a href="#传递引用的指导准则" class="headerlink" title="传递引用的指导准则"></a>传递引用的指导准则</h4><p>如果使用传递的值而不做修改：</p><ul><li>如果数据对象较小，如内置数据类型或者小型结构，则按值传递。</li><li>如果数据对象是数组，则只能使用指针，并且将指针声明为指向 const 的指针。</li><li>如果数据对象较大，则使用 const 指针或者 const 引用，节省复制结构所需的时间和空间。</li><li>如果数据对象是类对象，则使用 const 引用。类设计的语义常常要求使用引用。这是 C++增添引用这个特性的主要原因。</li></ul><p>如果需要修改调用函数中数据：</p><ul><li>如果数据对象是内置数据类型，则使用指针。</li><li>如果数据对象是数组，则只能使用指针。</li><li>如果数据对象是结构，则使用引用或者指针。</li><li>如果数据对象是类对象，则使用引用。</li></ul><h2 id="函数模板及其具体化"><a href="#函数模板及其具体化" class="headerlink" title="函数模板及其具体化"></a>函数模板及其具体化</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板（function template）使用泛型定义函数，泛型可用具体类型替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp;<br>    temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">swap</span>(a, b);         <span class="hljs-comment">//此时模板中的泛型 T 被 int 类型替换</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h3><p>由于模板函数有一定的局限性，比如上述模板 T 若是结构，假设不成立。因此使用显式具体化（explicit specialization）解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp;, T&amp;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//explicit specialization </span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> swap&lt;job&gt;<span class="hljs-params">(job &amp;, job &amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> a, b;<br>    <span class="hljs-built_in">swap</span>(a, b);  <span class="hljs-comment">//use template</span><br><br>    job c, d;<br>    <span class="hljs-built_in">swap</span>(c, d);  <span class="hljs-comment">//use void swap&lt;job&gt;(job &amp;, job &amp;)</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="显式和隐式实例化"><a href="#显式和隐式实例化" class="headerlink" title="显式和隐式实例化"></a>显式和隐式实例化</h3><p>编译器使用模板为特定的类型生成函数定义时，得到的时模板实例（instantiation），这个过程为隐式实例化（implicit instantiation）。C++还允许显式实例化，可以直接命令编译器生成函数定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">//这是显式实例化。该声明指出“使用 swap() 模板生成 int 类型的函数定义”。</span><br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">//这是显示具体化。该声明指出“不要使用 swap() 模板生成函数定义，而使用专门为 int 类型显式定义的函数定义”</span><br></code></pre></td></tr></table></figure><p>以下是对显式具体化、显式实例化和隐式实例化的总结：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp;, T&amp;)</span></span>;  <span class="hljs-comment">//模板原型</span><br><br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;job&gt;(job&amp;, job&amp;);  <span class="hljs-comment">//为 job 类型显式具体化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-type">char</span>&amp;, <span class="hljs-type">char</span>&amp;);  <span class="hljs-comment">//显式实例化，使用模板定义生成 swap() 的 char 版本的实例</span><br><br>    <span class="hljs-type">short</span> a, b;<br>    <span class="hljs-built_in">swap</span>(a, b);  <span class="hljs-comment">//使用模板生成 swap() 的 short 版本的实例</span><br><br>    job n, m;<br>    <span class="hljs-built_in">swap</span>(n, m);  <span class="hljs-comment">//使用 job 类型显式具体化的独立定义来生成实例</span><br>   <br>    <span class="hljs-type">char</span> g, h;<br>    <span class="hljs-built_in">swap</span>(g, h);  <span class="hljs-comment">//使用前面显式实例化时生成的实例</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 专业词汇中英对照</title>
    <link href="/2020/05/01/cpp-terminology/"/>
    <url>/2020/05/01/cpp-terminology/</url>
    
    <content type="html"><![CDATA[<p>先开一帖，学习过程中会不断补充，以后有空还会按照 C++ Primer Plus 的章节进行分类。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Text">reference                      引用<br>class                          类<br>library                        库<br>method                         方法<br>template                       模板<br>assignment                     赋值<br>argument                       参数<br>pointer                        指针<br>object                         对象<br>initialization                 初始化<br>lvalue                         左值<br>rvalue                         右值<br>vector                         向量<br>overload                       重载<br>explicit specialization        显式具体化<br>explicit instantiation         显式实例化<br>implicit instantiation         隐式实例化<br>ambiguous                      二义性<br>scope                          作用域<br>linkage                        链接性<br>definition                     定义<br>declaration                    声明<br>volatile                       无定性的<br>mutable                        可变的<br>invoke                         援引<br>constructor                    构造函数<br>destructor                     析构函数<br>type cast                      强制类型转换<br>derived class                  派生类<br>concrete class                 具体类<br>union                          并集<br>intersection                   交集<br>difference                     差集<br>symmetric difference           对称差集（只存在一个集合内的元素）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派搭建硬盘热插拔的家用 NAS</title>
    <link href="/2020/04/29/how-to-build-a-NAS-with-raspberry-pi/"/>
    <url>/2020/04/29/how-to-build-a-NAS-with-raspberry-pi/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月前，因为玩 Minecraft，在阿里云上开了个服和朋友愉快玩耍，开始了 Linux 的折腾之路。后来心血来潮入手了树莓派 4b，开始进一步的折腾。先是拿 c++照着别人用 python 写的天气闹钟复刻了一遍，然后又尝试了各种内网穿透方法用来远程 Wake on LAN 打开我家里的电脑。这个远程开机的实现以后应该也会写一篇文章记录一下，但是今天的主角是这个 NAS，也是我觉得树莓派买回家以后最有用的功能。</p><p>我爸最近总是在折腾他的蓝光电影和无损音乐，下满了好几个硬盘的电影和音乐，还在家添了好多设备。于是我就想，是不是可以搭建一个 NAS，以后他就不用整天拿着移动硬盘走来走去了。搭建 NAS 主要需要以下硬件：若干个硬盘，一个硬盘盒，一个树莓派。主要用到的软件有 Autofs 和 Samba。</p><h2 id="配置自动挂载实现热插拔（Autofs）"><a href="#配置自动挂载实现热插拔（Autofs）" class="headerlink" title="配置自动挂载实现热插拔（Autofs）"></a>配置自动挂载实现热插拔（Autofs）</h2><p>Linux 下，移动磁盘不会自动读取，需要通过命令行的 mount 指令手动挂载。当初我配置 NAS 的时候经常有拔出硬盘的需求，而每次拔出插回都需要自己进行手动挂载，非常麻烦且不实际。最终找到一个很好的解决方案，那就是 Autofs。它是一个自动挂载硬盘的软件，在硬盘被调用时会自动挂载硬盘，闲置一定时间后又会自动卸除，从而实现热插拔，并提高硬盘寿命。</p><p>首先安装 autofs 和 ntfs-3g，后者用于识别 ntfs 文件系统的硬盘，Linux 原生并不支持。</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">apt install autofs ntfs-3g<br></code></pre></td></tr></table></figure><p>插入硬盘盒后，先查看硬盘的地址，以及它的 uuid（由于我挂载多个盘，如果插拔，盘的地址可能会改变，如果用 uuid 识别就没有这个问题）。</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">fdisk -l    #查看磁盘分区<br></code></pre></td></tr></table></figure><p>之后就会显示出一系列的信息，找到如下的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Text">Disk /dev/sdb: 5.5 TiB, 6001175126016 bytes, 11721045168 sectors<br>Disk model: EZAZ-00ZGHB0    <br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: 373E356E-6A4F-11EA-8843-9CB6D01A3D23<br><br>Device      Start         End     Sectors  Size Type<br>/dev/sdb1    4096      618495      614400  300M EFI System<br>/dev/sdb2  618496      880639      262144  128M Microsoft reserved<br>/dev/sdb3  880640 11721045134 11720164495  5.5T Microsoft basic data<br>#找到/dev/sd *开头的，第一个盘是 a，以此类推。后面的数字代表是每个盘的分区。<br></code></pre></td></tr></table></figure><p>如果我要挂载上面 5.5T 的那个分区，那就记住它的 Device，也就是 sdb3。那么现在就开始查询它的 uuid，输入<code>blkid</code>，结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">#这里我只截出了刚刚要找的 sdb3<br>#注意是 UUID，不是 PARTUUID<br>/dev/sdb3: LABEL=&quot;M-eM-(M-1M-dM-9M-^P&quot; UUID=&quot;28FE0663FC407F1C&quot; TYPE=&quot;ntfs&quot; PTTYPE=&quot;atari&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;82c676e4-52f5-40ef-b058-2a206d6fa4e7&quot;<br></code></pre></td></tr></table></figure><p>那么接下来可以配置 autofs 了，首先打开：</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">vim /etc/auto.master<br></code></pre></td></tr></table></figure><p>找到有一行是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">/xxx    /auto.misc   #xxx 是挂载的目标文件夹，默认名字我忘了，我改成了/hdd<br></code></pre></td></tr></table></figure><p>然后添加要挂载的分区：</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">vim /etc/auto.misc<br></code></pre></td></tr></table></figure><p>在最下面加入一行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">disk1          -fstype=auto             UUID=**刚刚记下的 UUID**<br>#此时这个 UUID 对应的分区，就会被自动识别文件系统类型，被挂载到/hdd/disk1 上了<br>#将 UUID=****改成/dev/sdb3 也可以，但是不能热插拔。<br></code></pre></td></tr></table></figure><p>启动 autofs 服务：</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell">service autofs start<br>service autofs status   #查看状态<br>cd /hdd/disk1<br>ll                      #如果可以进入并且能够查看到磁盘中的文件就成功了<br></code></pre></td></tr></table></figure><p>最后讲一下热插拔。插拔硬盘前一定要确保没有读写文件，先关掉硬盘盒，确保硬盘完全断电，再拔下硬盘。插回硬盘后，可能不能马上读取文件，这是因为 autofs 默认 5 分钟卸载硬盘，如果没有到 5 分钟，它挂载的还是上一次拔出之前的位置，因此读取失败。解决方法，插下硬盘后不要马上使用即可，或者前往&#x2F;etc&#x2F;autofs.conf 中酌情缩短自动卸载的的等待时间。</p><h2 id="配置局域网网络共享（Samba）"><a href="#配置局域网网络共享（Samba）" class="headerlink" title="配置局域网网络共享（Samba）"></a>配置局域网网络共享（Samba）</h2><p>Samba 是一个网络共享软件，它将前面硬盘挂载的文件夹共享给局域网内的其他设备，我们家的电视、电脑、手机、机顶盒等所有能够读取网络共享文件的设备，就能轻松的从中播放电影、音乐了。废话少说先安装 samba 并配置：</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell">apt install samba<br>vim /etc/samba/smb.conf<br></code></pre></td></tr></table></figure><p>一直往下找到</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">#======================= Share Definitions ====================<br></code></pre></td></tr></table></figure><p>加一项</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Text">[RaspiNAS-disk1]<br>    # 说明信息<br>    comment = NAS Storage<br>    # 可以访问的用户<br>    valid users = pi<br>    # 共享文件的路径<br>    path = /hdd/disk1<br>    # 可被其他人看到资源名称（非内容）<br>    browseable = yes<br>    # 可写<br>    writable = yes<br>    # 新建文件的权限为 664<br>    create mask = 0664<br>    # 新建目录的权限为 775<br>    directory mask = 0775<br></code></pre></td></tr></table></figure><p>接下来配置 samba 账户然后启动，无账户能不能用我还没试过，试过的小伙伴可以评论区说一下。</p><figure class="highlight shell"><figcaption><span>Session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell">smbpasswd -a pi     #之后别的设备要访问就用这个 pi 来登录<br>service smbd start  #没记错的话是默认自启的<br>service smbd status<br></code></pre></td></tr></table></figure><p>接下来就配置完成了，打开电脑试一下。再资源管理器地址栏输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">\\192.168.3.115\disk1   #前面的 ip 是你树莓派的内网 ip<br></code></pre></td></tr></table></figure><p>如果不知道 ip 是多少可以在树莓派命令行输入<code>ifconfig</code>:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Text">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.3.115  netmask 255.255.255.0  broadcast 192.168.3.255<br>        inet6 fe80::1861:adc2:86b0:3e3d  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether dc:a6:32:14:ee:ff  txqueuelen 1000  (Ethernet)<br>        RX packets 42476257  bytes 3954948248 (3.6 GiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 5541153  bytes 320192749 (305.3 MiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>#inet 后面的 ip 地址就是<br></code></pre></td></tr></table></figure><p>如果想要快速的访问，可以对挂载的文件夹右键-&gt;映射网络驱动器-&gt;完成。看看成果：<br><img src="/img/post2/post2-1.jpg">  </p>]]></content>
    
    
    <categories>
      
      <category>Linux 应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Raspberry Pi</tag>
      
      <tag>NAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/04/25/hello-world/"/>
    <url>/2020/04/25/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;<span class="hljs-string">&quot;Hello World!&quot;</span>;<br></code></pre></td></tr></table></figure><p>相信每个编程初学者对上面这行代码并不陌生。”Hello World!”就像是每个刚来到这个世界的婴儿，对一切都无比陌生好奇时的一句宣言。这篇文章是我在这个博客上的第一篇，没有什么能和这句话媲美，它完美的诠释了我现在的心情。这篇文章主要是用来练练手，毕竟是第一次写博客，对 markdown 的语法也不熟悉，折腾了很久。在这里，我会大概写一下这两天搭建博客和搭建写作环境的大体过程。</p><h2 id="博客的搭建"><a href="#博客的搭建" class="headerlink" title="博客的搭建"></a>博客的搭建</h2><p>事实上，我在两个地方上搭建了我的博客，一个是在我的 vps 上，一个在我的 <a href="https://desmond121.github.io/">github.io</a> 上面。关于整个搭建的流程大概可以这样概括：先分别在本地的电脑和 vps 上搭建 git 的客户端和服务端（实际上 github 就是一个 git 服务端，因此我只需要在我的 vps 上搭建）。接下来就是搭建 hexo 博客环境（需要先安装 nodejs 框架）。最后是安装 nginx 用作 web 服务器。</p><h3 id="Git-客户端服务端搭建"><a href="#Git-客户端服务端搭建" class="headerlink" title="Git 客户端服务端搭建"></a>Git 客户端服务端搭建</h3><p>Git 是一个高效的版本管理系统，在搭建博客的过程中他起到的作用是快速将生成的静态博客分发部署到 github 和 vps 上面。搭建流程主要是：先在本地电脑安装服务端，生成 ssh 的密钥。再在服务端安装 git-core，配置好 git 用户（这真的是最容易出问题的一步，尤其是权限的设置，之前漏了一布，导致后面 git 钩子没能把分发好的静态博客部署到位），写好 git 钩子的脚本 post-receive，配置好 blog.git 文件夹。</p><h3 id="Nginx-的配置"><a href="#Nginx-的配置" class="headerlink" title="Nginx 的配置"></a>Nginx 的配置</h3><p>Nginx 主要用作 web 服务器。我家里有一个被我用作 NAS 的树莓派，我给它配置了一个 aria2 的 web-gui 的插件，当时是用 apache2 做的 web 服务器，所以我一开始也准备用回 apache2，节省学习成本。但是结果我发现我的 vps 是 centos 系统，而 apache2 在 redhat 系的系统上的名字叫 httpd，不但名字不一样，配置文件也不同，找到的教程和我的版本好像又不一样。试了半个小时什么进展都没有，果断放弃，换 nginx。</p><p>配置 nginx 的教程网上一抓一大把，我就不写了，再说了我也只是一知半解，还是不要误人子弟为好。配置 nginx 的时候我发现 80 端口居然给我以前配置的内网穿透 ngrok 给占了，反正最近都不出门，我就把它关了。</p><h3 id="搭建-hexo-博客环境"><a href="#搭建-hexo-博客环境" class="headerlink" title="搭建 hexo 博客环境"></a>搭建 hexo 博客环境</h3><p>因为 hexo 实际上是个静态博客，在本地写完文章生成文件，通过 git 分发到服务器上，所以 hexo 是配置在本地电脑上的。我刚开始没了解清楚，一股脑把全部东西都安装在 vps 上了（包括 git，那个时候我还没明白 git 的工作原理），直到我发现我在帮 vps 上的 git 自己给自己建立 ssh 连接的时候，我才意识到这个问题。</p><p>回归正题，hexo 博客的环境搭建主要就两步：先搭建 nodejs 环境，通过 nodejs 的包管理指令 npm 直接安装 hexo。hexo 的官方文档还是很清楚的，所以基本上没有什么问题。搭建完之后我又花了几个小时来找好看的 hexo 主题（选择困难症太惨了 QAQ），最后用了一个国人做的 <a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>。它的官方文档很全，自定义的内容也很多，总之就是又好看功能又强大。</p><p>搭建好之后，编辑好自己的博客，设置一下配置文件，通过 git 将静态博客文件分发到 github 和 vps 上，vps 上还有额外一个步骤就是用 git 钩子将分发好的源文件部署到 nginx 的 web 服务器文件位置，就可以访问博客啦！</p><h2 id="搭建写作环境"><a href="#搭建写作环境" class="headerlink" title="搭建写作环境"></a>搭建写作环境</h2><p>hexo 用的是 github 的 GitHub Flavored Markdown, 是 markdown 与语言的一个变种，略有不同。首先，编写博客需要一个文本编辑器，我选用了 github 的 atom。atom 的功能真的很强大，可以通过各种包来扩展功能，我主要装了和 markdown 有关的。下面是我安装的包：</p><ul><li>atom-hexo ——用于可以在 atom 控制台使用一些 hexo 指令</li><li>hexo-front-matter ——一键生成文章的头部</li><li>hexo-insert-image ——插入图片用，我还没试过</li><li>markdown-img-paste ——似乎是用来插入剪切板里的图片的，截图党的福音</li><li>markdown-previe-plus ——这个就是 markdown 的实时预览，必装</li><li>markdown-table-editor ——编辑图表用的</li></ul><p>其他的包我还没有装，以后装了好用再补充。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Blog</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
